/*
 * RetroGB

 * Copyright (C) 2016  Michael Kösel

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace CpuGenerator
{
    // TODO Cleanup and finish generator
    partial class Generator
    {
        public Generator()
        {
        }

        public void Generate(TextWriter writer)
        {
            writer.WriteLine("//-------------------------------------------------------------------------------------");
            writer.WriteLine("// This is file was generated by CpuGenerator.");
            writer.WriteLine("// Do not edit this file manually or all your changes will be lost after re-generation.");
            writer.WriteLine("//-------------------------------------------------------------------------------------");
            writer.WriteLine();

            writer.WriteLine("#include \"Processor.h\"");
            writer.WriteLine("#include \"BitUtil.h\"");
            writer.WriteLine();

            StreamReader opReader = new StreamReader("opcodes.json");
            List<Opcode> opCodes = JsonConvert.DeserializeObject<List<Opcode>>(opReader.ReadToEnd());

            StreamReader cbReader = new StreamReader("opcodesCB.json");
            List<Opcode> opCodesCB = JsonConvert.DeserializeObject<List<Opcode>>(cbReader.ReadToEnd());

            // Should already be sorted
            opCodes.Sort((x, y) => x.Address.CompareTo(y.Address));
            opCodesCB.Sort((x, y) => x.Address.CompareTo(y.Address));

            writer.WriteLine("void Processor::InitOpcodes()");
            writer.WriteLine("{");

            foreach (Opcode opcode in opCodes)
            {
                string line = opcode.Operation;

                if (line != "UNDEFINED")
                {
                    MapOpcode(writer, opcode);
                }
                else
                {
                    MapInvalidOpcode(writer, opcode);
                }
            }

            writer.WriteLine();
            writer.WriteLine("\t// CB Obcodes");

            foreach (Opcode opcode in opCodesCB)
            {
                string line = opcode.Operation;

                MapCBOpcode(writer, opcode);
            }

            writer.WriteLine("}");
            writer.WriteLine();

            foreach (Opcode opcode in opCodes)
            {
                string operation = opcode.Operation;

                if (operation != "UNDEFINED")
                {
                    GenerateMethod(writer, opcode);
                }
            }

            writer.WriteLine("// CB Obcodes");
            writer.WriteLine();

            foreach (Opcode opcode in opCodesCB)
            {
                GenerateMethod(writer, opcode);
            }

            opReader.Close();
            cbReader.Close();
        }

        public void GenerateMethod(TextWriter writer, Opcode opcode)
        {
            writer.WriteLine("/* {0} */", opcode.ToCompleteOpName());
            writer.WriteLine("unsigned int Processor::{0}() // 0x{1:X2}", opcode.ToFunctionName(), opcode.Address);
            writer.WriteLine("{");

            WriteOpcodeStub(writer, opcode);

            writer.WriteLine();
            writer.WriteLine("\treturn {0};", opcode.Cycles);

            writer.WriteLine("}");
            writer.WriteLine();
        }

        private void WriteOpcodeStub(TextWriter writer, Opcode opcode)
        {
            string operation = opcode.Operation;
            string firstOperand = opcode.FirstOperand;
            string secondOperand = opcode.SecondOperand;

            string first = GetStoreStub(firstOperand);
            string second = GetLoadStub(secondOperand);

            switch (operation)
            {
                case "NOP":
                    break;
                case "STOP":
                    writer.WriteLine("\tPC++;");
                    break;
                case "LD":
                    if (firstOperand != secondOperand)
                    {
                        if (firstOperand == "HL" && secondOperand == "SP+n")
                        {
                            WriteHLSPN(writer, opcode);
                        }
                        else
                        {
                            if (firstOperand == "(nn)" && secondOperand == "A")
                                writer.WriteLine("\tmemory->WriteByte(memory->ReadWord(PC), A);");
                            else
                                writer.WriteLine("\t" + string.Format(first, second));

                            if (secondOperand == "nn" || secondOperand == "(nn)" || firstOperand == "(nn)")
                                writer.WriteLine("\tPC += 2;");
                        }
                    }
                    break;
                case "INC":
                    if (firstOperand == "BC" || firstOperand == "DE" || firstOperand == "HL" || firstOperand == "SP")
                        WriteIncWord(writer, opcode);
                    else
                        WriteIncByte(writer, opcode);
                    break;
                case "DEC":
                    if (firstOperand == "BC" || firstOperand == "DE" || firstOperand == "HL" || firstOperand == "SP")
                        WriteDecWord(writer, opcode);
                    else
                        WriteDecByte(writer, opcode);
                    break;
                case "AND":
                    WriteAnd(writer, opcode);
                    break;
                case "OR":
                    WriteOr(writer, opcode);
                    break;
                case "XOR":
                    WriteXor(writer, opcode);
                    break;
                case "ADD":
                    if (firstOperand == "HL" || firstOperand == "SP")
                        WriteAddWord(writer, opcode);
                    else
                        WriteAdd(writer, opcode);
                    break;
                case "ADC":
                    WriteAdc(writer, opcode);
                    break;
                case "SUB":
                    WriteSub(writer, opcode);
                    break;
                case "SBC":
                    WriteSbc(writer, opcode);
                    break;
                case "DI":
                    WriteDi(writer, opcode);
                    break;
                case "EI":
                    WriteEi(writer, opcode);
                    break;
                case "BIT":
                    WriteBit(writer, opcode);
                    break;
                case "SET":
                    if (secondOperand != "(HL)")
                        WriteSet(writer, opcode);
                    else
                        WriteHLSet(writer, opcode);
                    break;
                case "RES":
                    if (secondOperand != "(HL)")
                        WriteRes(writer, opcode);
                    else
                        WriteHLRes(writer, opcode);
                        break;
                case "CALL":
                    WriteCall(writer, opcode);
                    break;
                case "RET":
                    WriteRet(writer, opcode);
                    break;
                case "RETI":
                    WriteReti(writer, opcode);
                    break;
                case "PUSH":
                    WritePush(writer, opcode);
                    break;
                case "POP":
                    WritePop(writer, opcode);
                    break;
                case "JR":
                    WriteJr(writer, opcode);
                    break;
                case "JP":
                    if (firstOperand == "(HL)")
                        writer.WriteLine("\tPC = HL;");
                    else
                        WriteJp(writer, opcode);
                    break;
                case "DAA":
                    WriteDaa(writer, opcode);
                    break;
                case "CPL":
                    WriteCpl(writer, opcode);
                    break;
                case "CCF":
                    WriteCcf(writer, opcode);
                    break;
                case "SCF":
                    WriteScf(writer, opcode);
                    break;
                case "CP":
                    WriteCp(writer, opcode);
                    break;
                case "HALT":
                    WriteHalt(writer, opcode);
                    break;
                case "RST":
                    WriteRst(writer, opcode);
                    break;
                case "SWAP":
                    if (firstOperand != "(HL)")
                        WriteSwap(writer, opcode);
                    else
                        WriteSwapHL(writer, opcode);
                    break;
                case "RL":
                    WriteRl(writer, opcode);
                    break;
                case "RLC":
                    WriteRlc(writer, opcode);
                    break;
                case "RR":
                    WriteRr(writer, opcode);
                    break;
                case "RRC":
                    WriteRrc(writer, opcode);
                    break;
                case "RLA":
                    WriteRl(writer, opcode, true);
                    break;
                case "RLCA":
                    WriteRlc(writer, opcode, true);
                    break;
                case "RRA":
                    WriteRr(writer, opcode, true);
                    break;
                case "RRCA":
                    WriteRrc(writer, opcode, true);
                    break;
                case "SLA":
                    WriteSla(writer, opcode, true);
                    break;
                case "SRA":
                    WriteSra(writer, opcode, true);
                    break;
                case "SRL":
                    WriteSrl(writer, opcode, true);
                    break;
                default:
                    writer.WriteLine("\t// Not implemented yet");
                    writer.WriteLine("\tUnknownOpcode();");
                    break;
            }
        }

        public void MapOpcode(TextWriter writer, Opcode opcode)
        {
            var funcName = opcode.ToFunctionName();
            writer.WriteLine("\topcodes[0x{0:X2}] = std::bind(&Processor::{1}, this);", opcode.Address, funcName);
        }

        public void MapInvalidOpcode(TextWriter writer, Opcode opcode)
        {
            writer.WriteLine("\topcodes[0x{0:X2}] = std::bind(&Processor::InvalidOpcode, this);", opcode.Address);
        }

        public void MapCBOpcode(TextWriter writer, Opcode opcode)
        {
            var funcName = opcode.ToFunctionName();
            writer.WriteLine("\topcodesCB[0x{0:X2}] = std::bind(&Processor::{1}, this);", opcode.Address, funcName);
        }
    }
}
